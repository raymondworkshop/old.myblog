I"ü<h4 id="stack-filo-first-in-last-out-1">Stack: FILO (first in, last out) <a href="http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html" title="stack and heap">1</a></h4>
<ul>
  <li>Stored in computer RAM</li>
  <li>
    <p>stack grows and shrinks as functions push and pop local variables;
   Variables are allocated and freed automatically .</p>
  </li>
  <li>CPU manage the memory, reading from and writing to stack variables is very fast</li>
</ul>

<h4 id="heap-1">Heap <a href="http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html" title="stack and heap">1</a></h4>
<ul>
  <li>Stored in computer RAM</li>
  <li>heap variables are essentially global in scope.</li>
  <li>
    <p>Heap memory is slightly slower to be read from and written to, 
   because one has to use pointers to access memory on the heap.</p>
  </li>
  <li>If we need variables like arrays and structs that can change size dynamically,
   then we will likely need to allocate them on the heap.</li>
</ul>

<h4 id="queue--fifo">queue : FIFO</h4>

<h4 id="stack--filo-first-in-last-out">stack : FILO (first in, last out)</h4>

<h4 id="priority-queue">Priority Queue</h4>
<ul>
  <li>The case
    <ul>
      <li>
        <p>We collect a set of items, then process the one with the largest key, <strong>then perhaps collect more items</strong>,
then process the one with the current largest key.</p>
      </li>
      <li>
        <p>a collection in which items can be added at any time, but the only item that can be removed is the one
 with the <strong>highest priority</strong>.</p>
      </li>
    </ul>
  </li>
  <li>The implementations
    <ul>
      <li>unordered array/linked-list:
        <ul>
          <li>To insert: push in the stack. O(1)</li>
          <li>To remove the max: exchange the MAX with the item at the end, and then delete that one. o(n)</li>
        </ul>
      </li>
      <li>ordered array/linked-list:
        <ul>
          <li>for insert to move larger entries on the right position,thus keeping the keys in the order array. o(n)</li>
          <li>The MAX is always at the end. O(1)</li>
        </ul>
      </li>
      <li><strong>binary heap</strong> <a href="http://cs.lmu.edu/~ray/notes/pqueues/" title="priority queue">2</a></li>
      <li>a binary tree is heap-ordered if the key in each node &gt;= the keys in the node‚Äôs two children <a href="http://algs4.cs.princeton.edu/24pq/" title="Priority Queues">3</a>.</li>
      <li>To insert: <strong>exchanging the node with its parent</strong> to restore the heap condition</li>
      <li>To remove:
        <ul>
          <li>take the key off the top;</li>
          <li>put the item at the end of the heap to the top,</li>
          <li>and then sink through the heap with the key to restore the heap condition</li>
        </ul>
      </li>
      <li>
        <p>In a heap, the highest (or lowest) priority item is always stored <strong>at the root</strong>, hence the name ‚Äúheap‚Äù.
  A heap is not a sorted structure and can be regarded as <strong>partially ordered</strong> . There is no particular
  relationship among ndoes on any given level, even among the siblings <a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html" title="priority queues">4</a>.</p>
      </li>
      <li>
        <p>A heap is useful data structure when we need to <strong>remove the object with the highest (or lowest) priority</strong>.</p>
      </li>
      <li>O(logN)</li>
    </ul>
  </li>
</ul>

:ET