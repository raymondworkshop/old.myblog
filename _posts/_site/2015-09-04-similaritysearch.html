<h4 id="similarity-search-1">Similarity Search <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></h4>
<ul>
  <li>
    <p>Similarity Search in high-dimensional spaces becomes increasingly important in databases, data mining, and search engines,particularly for content-based search of feature-rich data such as audio recordings, digital photos, digital videos and other sensor data. Since feature-rich data objects are typically represented as high-dimensional feature vectors.</p>
  </li>
  <li>
    <p>The problem of similarity search refers to finding objects that have similar characteristics to the query object.  Similarity search is usually implemented as K-Nearest Neighbor (KNN) or Approximate Nearest Neighbors (ANN) search in high-dim feature-vector space.</p>

    <ul>
      <li>KNN: find  the K objects that are closest to q according to a distance function</li>
      <li>ANN: find K objects whose distances are within a small factor (1 + x) of the true K-nearest neighbors’s distances</li>
    </ul>
  </li>
  <li>
    <p>An ideal indexing scheme for similarity search:</p>
    <ul>
      <li>Accurate: very close to those of the brute-force, linear-scan approach</li>
      <li>Time efficient: O(logN)</li>
      <li>Space efficient: the index data structure may even fit into main memory</li>
      <li>High-dimensional:  the indexing scheme should work well for datasets with very high intrinsic
  dimensionalities</li>
    </ul>
  </li>
</ul>

<h4 id="the-related-approaches">The related approaches</h4>
<ul>
  <li>tree-based indexing methods for K-Nearest Neighbor(KNN)
    <ul>
      <li>
        <p>K-D tree: not time efficient for data with high-dim</p>
      </li>
      <li>
        <p>TODO</p>
      </li>
    </ul>
  </li>
  <li>the indexing method: LSH  <sup id="fnref:1:1"><a href="#fn:1" class="footnote">1</a></sup>
    <ul>
      <li>
        <p>use hash functions to <strong>map similar objects into the same hash buckets with high probability</strong> .</p>

        <p>using LSH functions to select candidate objects for a given query q,
and ranking the candidate objects according to their distances to q.</p>
      </li>
      <li>
        <p>Drawback: to achieve high search accuracy, the LSH method needs to use multiple hash tables to produce a good candidate set.</p>

        <ul>
          <li>
            <p>Experimental studies show that the basic LSH needs hundreds hash tables to achieve good search accuracy for high-dimensional datasets.</p>
          </li>
          <li>
            <p>The size of each hash table is proportional to the number of data objects, since each table has <strong>as many
entries as the number of data objects</strong> in the dataset.
When the space requirement for the hash tables exceeds the main memory size, looking up a hash bucket may require a disk I/O, causing substantial delay to the query process.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>The approach does not satisfy the space-efficiency requirement.</p>
      </li>
    </ul>
  </li>
  <li>Multi-probe LSH <sup id="fnref:1:2"><a href="#fn:1" class="footnote">1</a></sup>
    <ul>
      <li>
        <p>The main idea is to build on the basic LSH indexing method, but to use <strong>a carefully derived probing
  sequence to look up multiple buckets</strong> that have a high probability of containing the nearest neighbors of a query object.</p>
      </li>
      <li>
        <p>Given the property of LSH, if an object is close to a query object q but not hashed to the same bucket as q, it is likely to be in <strong>a buckets  that is “close by”</strong> (i.e. the hash values of the two buckets only differ slightly).</p>
      </li>
      <li>
        <p>By probing multiple buckets in each hash table, the method requires far fewer hash tables than previous LSH methods</p>
      </li>
    </ul>
  </li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>“Multi-probe LSH: Efficient indexing for high-dimensional similarity search” by Q.Lv, W.Josephson, Z. Wang, M. Charikar, and K. Li, VLDB <a href="#fnref:1" class="reversefootnote">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote">&#8617;<sup>2</sup></a> <a href="#fnref:1:2" class="reversefootnote">&#8617;<sup>3</sup></a></p>
    </li>
  </ol>
</div>
