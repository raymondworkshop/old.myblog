<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="pragma" content="no-cache">
        <link href="/css/style.css" media="screen" rel="stylesheet" type="text/css"></link>
        <link href="/css/mobile.css" media="handheld, only screen and (max-device-width: 960px)" rel="stylesheet" type="text/css"></link>
        <link href="/css/pygments.css" media="screen" rel="stylesheet" type="text/css"></link>
        <link href="/css/fonts.css" rel="stylesheet">
        <link href="http://feeds.feedburner.com/github/FETh"
        type="application/atom+xml" rel="alternate" title="情书.feed" />

        <meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@_muyun">
<meta name="twitter:creator" content="@_muyun">

  <meta name="twitter:title" content="Search Algorithms: Binary Search Trees">


  <meta name="twitter:url" content="/algorithms/2014/05/25/search-algorithms-binary-search-trees.html">



<meta name="twitter:description" content="">



        <title>Search Algorithms: Binary Search Trees </title>
    </head>
    
    <body>
        
        <div class="menu">
            <h1> 情书</h1>
            <em> by muyun_</em>
            
            <ul class="nobullet pagelinks">
                <li class="menulinks"><a href="/">writing</a></li>
                <li class="menulinks"><a href="/shorts.html">bits</a></li>
                
                <li class="menulinks"><a href="/delicious.html">delicious</a></li>
                
                <li class="menulinks"><a href="/blogroll.html">links</a></li>
                <li class="menulinks"><a href="/about.html">about</a></li>
            </ul>
            
            <hr class="hidemobile">
            
            <ul class="nobullet linkicons">
              <li><a href="http://feeds.feedburner.com/github/FETh"><i class="icon-rss"> </i></a></li>
              <li><a href="https://github.com/muyun"><i class="icon-github-sign"> </i></a></li>
              <li><a href="https://twitter.com/_muyun"><i class="icon-twitter"> </i></a></li>
              
              <li><a href="http://www.weibo.com/2126155907/profile?topnav=1&wvr=6"><i class="icon-weibo"> </i></a></li>
 
            </ul>
        </div>
        
        <div id="wrapper">
            <div id="content">
                <div class="postdateheading"> May 25, 2014 </div>
<div> <h2 style="color:#840044"> Search Algorithms: Binary Search Trees </h2> </div>
<div class="post">
    <p>Binary search trees (BST) combines the flexibility of insertion in a
linked list (using two links per node leads to an efficient
implementation) with the efficiency of search in an ordered array.</p>

<p>BST is a binary tree in symmetric order. A binary tree either either
or two disjoint binary trees.  Symmetric order means that each node&#39;s
key is larger than all keys in its left subtree, and smaller than all
keys in its right subtree.</p>

<p>A Node is comprised of four fields: a key and a value; a reference to
the left (smaller keys) and right subtree (larger keys).</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Key</span> <span class="n">key</span><span class="o">;</span>   
        <span class="kd">private</span> <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>  <span class="c1">// the left link points to a BST for items with smaller keys</span>
        <span class="kd">private</span> <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>  <span class="c1">// the right link points to a BST for items with larger keys</span>

        <span class="kd">public</span> <span class="nf">Node</span> <span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">){</span>
           <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
           <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>
<ul>
<li>The Implementation:</li>
</ul>

<p>The search use the recursive algorithm to search for a key, the function get()</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">get</span> <span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">){</span>
    <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>  <span class="c1">//starting with the root of the tree</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>The insert put key-value pair into BST, if key already exists, update
with new value, the function put()</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">){</span>
    <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span> <span class="c1">//x.left is null, after new Node, put this ref to the new node into x.left</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="k">else</span>
        <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<ul>
<li>Performance Analysis:</li>
</ul>

<p>The running times depend on the shapes of the trees, which depends on the <strong>order in which the
keys come in (insert)</strong>.  (If the key is inserted in natural order, this is no difference from
linked list).</p>

<p><strong>Binary search trees correspond exactly to Quicksort partitioning</strong>. In
the binary search trees, we have a root, and everybody smaller to the
left, and everybody larger to the right. In the Quicksort
partitioning, after the random shuffling, we have the partitioning
element and then we process everybody to the left independently of
everybody to the right, so, if N <strong>distinct keys</strong> are inserted into a BST
<strong>in random order</strong>, the expected number of compares for a
search/insert is <strong>~2lnN(about 1.39lgN) on the average</strong> . But there&#39;s problem that the actual worst
case height if the keys come in in order and reverse order and other
natural orders (the worst tree shape), that the time could be proportional to ~N .</p>

<ul>
<li>References: 

<ul>
<li><a href="http://algs4.cs.princeton.edu/32bst/">Binary Search Trees</a></li>
</ul></li>
</ul>

</div>
<p>
  Copyright &copy; - muyun_ -
  <span class="credit">Powered by <a href="http://jekyllrb.com/">Jekyll</a></span>
</p>


<!--
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="en">Tweet</a>
<a href="https://twitter.com/_muyun" class="twitter-follow-button" data-show-count="false" data-lang="en">Follow @_muyun</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

-->


            </div>
        </div>
        <script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '4e511776613f5d3738000002');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    </body>
</html>
