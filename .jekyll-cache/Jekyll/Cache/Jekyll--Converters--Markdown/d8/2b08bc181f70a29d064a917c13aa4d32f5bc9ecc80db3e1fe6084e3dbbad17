I"|<h4 id="unix-standards">Unix Standards</h4>

<p>Unix standards originally developed to reconcile the APIs of the different branches of the family tree.</p>

<p>Later, during the Unix wars, <strong>technical standardization</strong> became something that cooperating technical people pushed for and most product managers accepted grudgingly or actively resisted.</p>

<p>In fact, on the the newer open-source Unixes (such as Linux) it is common for operating system features to have been engineered <strong>using published standards as the specification</strong>.</p>

<h4 id="rfc-a-request-for-comments--standard">RFC (A Request for Comments ) Standard</h4>

<p>The IETF Standards process is designed to encourage standarization <strong>driven by practice rather than theory</strong>, and to ensure that standard protocols have undergine <strong>rigorous peer review and testing</strong>.</p>

<p><strong>The IETF (The Internet Engineering Task Force)</strong> Standards Process:</p>
<blockquote>
  <p>Internet-Drafts (focal points for discussion in a working group)<br />
-&gt; RFC (correct field experience with the specification)<br />
-&gt; Proposed Standards (the specification must be stable, peer-reviewed, and significants interests)<br />
-&gt; Draft Standard (the specification is mature and will be useful)<br />
-&gt; Internet Standard</p>
</blockquote>

<h4 id="specifications-as-dna-code-as-rna">Specifications as DNA, code as RNA</h4>

<p>The Unix traditionâ€™s emphasis on <strong>modularity makes Unix programmers usually to scrap and rebuild</strong>. The IETF tradition teaches us to think of code as secondary to standards.  The IETF showed us that <strong>careful standardization is to capture the best of existing practice</strong>.</p>

<p>Experience, and a strong tradition of collaborative development, had already taught Unix programmers that <strong>prototyping and repeated cycles of test and re-specification</strong> are a better way.</p>

<p>This <strong>standards-come-first scrap-and-rebuild culture</strong> of Unix tends to yield better interoperability over extended time than <strong>perpetual patching of a code base without a standard</strong> or to provide guidance and continuity.</p>

<h4 id="open-standards-and-open-source">Open standards and Open source</h4>

<p><strong>Open-source implementations of a published standard</strong> can both tremendously reducing your coding workload. With open-source code, you have a path forward, because you have access to source code, you can forward-port it to new platforms if you need to .</p>

<p>Practice defensive design - build on open source.</p>

<h4 id="documentation---explaining-your-code-to-a-web-centric-world">Documentation - Explaining your code to A web-centric World</h4>

<h4 id="open-source---programming-in-the-unix-community">Open Source - Programming in the Unix Community</h4>

<p>Most contributors in Open-source development are <strong>volunteers contributing</strong> in order to be <strong>rewarded by the increased usefulness of the software to them</strong>, and by <strong>reputation incetives</strong>, thus <strong>Process transparency and peer review</strong> are the crucial steps in the open-source development.</p>

<h4 id="reference">reference</h4>
<ul>
  <li>The Art of Unix Programming</li>
  <li><a href="https://jvns.ca/blog/2017/08/06/contributing-to-open-source/">Figuring out how to contribute to open source</a></li>
</ul>

:ET